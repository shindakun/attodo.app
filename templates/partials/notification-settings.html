{{define "notification-settings.html"}}
<article id="notification-settings">
    <h3>Notification Settings</h3>

    <div id="notification-status">
        <p>
            <strong>Browser Notifications:</strong>
            <span id="notification-permission-status">Checking...</span>
        </p>
        <div id="registered-devices" style="display: none; margin-top: 1rem;">
            <p><strong>Registered Devices:</strong></p>
            <ul id="device-list" style="font-size: 0.9rem; color: var(--pico-muted-color); list-style: none; padding: 0;"></ul>
        </div>
    </div>

    <div id="notification-controls">
        <button id="enable-notifications" style="display: none;">
            Enable Push Notifications
        </button>

        <button id="register-device" style="display: none;" class="secondary">
            Register This Device
        </button>

        <div id="notification-preferences" style="display: none;">
            <h4>Notification Timing</h4>

            <label>
                <input type="checkbox" id="notify-overdue" checked>
                Notify me about overdue tasks
            </label>

            <label>
                <input type="checkbox" id="notify-today" checked>
                Notify me about tasks due today
            </label>

            <label>
                <input type="checkbox" id="notify-soon">
                Notify me about tasks due within 3 days
            </label>

            <label>
                Advance notice (hours before due):
                <input type="number" id="notify-hours-before" min="0" max="72" value="1" style="width: 80px;">
            </label>

            <h4>Check Frequency</h4>
            <label>
                <select id="check-frequency">
                    <option value="15">Every 15 minutes</option>
                    <option value="30" selected>Every 30 minutes</option>
                    <option value="60">Every hour</option>
                    <option value="120">Every 2 hours</option>
                </select>
            </label>

            <h4>Quiet Hours</h4>
            <label>
                <input type="checkbox" id="quiet-hours-enabled">
                Enable Do Not Disturb mode
            </label>

            <div id="quiet-hours-controls" style="display: none; margin-left: 1.5rem;">
                <label>
                    Start time (hour):
                    <input type="number" id="quiet-start" min="0" max="23" value="22" style="width: 80px;">
                    <small>Default: 10 PM (22)</small>
                </label>

                <label>
                    End time (hour):
                    <input type="number" id="quiet-end" min="0" max="23" value="8" style="width: 80px;">
                    <small>Default: 8 AM (8)</small>
                </label>
            </div>

            <button onclick="saveNotificationSettings()">Save Preferences</button>
            <button onclick="testNotification()" class="secondary">Send Test Notification</button>
        </div>
    </div>

    <hr>

    <h3>User Interface Preferences</h3>

    <label>
        <input type="checkbox" id="task-input-collapsed">
        Collapse task input form by default
        <small style="display: block; margin-top: 0.25rem; color: var(--pico-muted-color);">
            When enabled, the "Add New Task" form will be collapsed when you visit the dashboard. You can still use the Command Bar (Cmd+Shift+P) to quickly add tasks.
        </small>
    </label>

    <button onclick="saveUIPreferences()">Save UI Preferences</button>
</article>

<script>
// Show/hide quiet hours controls based on checkbox
document.getElementById('quiet-hours-enabled')?.addEventListener('change', (e) => {
    document.getElementById('quiet-hours-controls').style.display =
        e.target.checked ? 'block' : 'none';
});

// Notification settings management
let currentSettings = null; // Cache current settings

// Fetch current settings
async function loadSettings() {
    try {
        const response = await fetch('/app/settings');
        if (!response.ok) throw new Error('Failed to load settings');
        return await response.json();
    } catch (error) {
        console.error('Error loading settings:', error);
        // Return defaults if fetch fails
        return {
            notifyOverdue: true,
            notifyToday: true,
            notifySoon: false,
            hoursBefore: 1,
            checkFrequency: 30,
            quietHoursEnabled: false,
            quietStart: 22,
            quietEnd: 8,
            pushEnabled: false,
            taskInputCollapsed: false
        };
    }
}

// Save settings
async function saveSettings(settings) {
    try {
        const response = await fetch('/app/settings', {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(settings)
        });

        if (!response.ok) throw new Error('Failed to save settings');
        return await response.json();
    } catch (error) {
        console.error('Error saving settings:', error);
        throw error;
    }
}

async function initNotificationSettings() {
    // Check notification permission status
    if (!('Notification' in window)) {
        document.getElementById('notification-permission-status').textContent =
            'Not supported in this browser';
        return;
    }

    const permission = Notification.permission;
    const statusEl = document.getElementById('notification-permission-status');
    const enableBtn = document.getElementById('enable-notifications');
    const registerBtn = document.getElementById('register-device');
    const prefsEl = document.getElementById('notification-preferences');

    // Load settings from AT Protocol
    const settings = await loadNotificationSettings();

    // Check if user has pushEnabled from another device
    const pushEnabledOnAnyDevice = settings && settings.pushEnabled === true;

    if (permission === 'granted') {
        statusEl.textContent = 'Enabled ✓';
        statusEl.style.color = 'var(--pico-primary)';
        prefsEl.style.display = 'block';
        registerBtn.style.display = 'inline-block';

        // Ensure we have a push subscription (idempotent)
        await subscribeToPush();

        // Load and display registered devices
        await loadRegisteredDevices();
    } else if (permission === 'denied') {
        statusEl.textContent = 'Blocked (check browser settings)';
        statusEl.style.color = 'var(--pico-del-color)';

        // If user has notifications enabled on other devices, show preferences
        if (pushEnabledOnAnyDevice) {
            prefsEl.style.display = 'block';
        }
    } else {
        // Permission is 'default' (not yet asked)
        if (pushEnabledOnAnyDevice) {
            // User has notifications enabled on another device
            statusEl.textContent = 'Not enabled on this device';
            statusEl.style.color = 'var(--pico-muted-color)';
            enableBtn.style.display = 'block';
            prefsEl.style.display = 'block'; // Show preferences
            registerBtn.style.display = 'none'; // Hide register button until permission granted
        } else {
            // First time setup
            statusEl.textContent = 'Not enabled';
            enableBtn.style.display = 'block';
        }
    }
}

async function loadRegisteredDevices() {
    try {
        const response = await fetch('/app/push/subscriptions');
        if (!response.ok) return;

        const data = await response.json();
        const subscriptions = data.subscriptions || [];

        if (subscriptions.length > 0) {
            const deviceList = document.getElementById('device-list');
            const devicesContainer = document.getElementById('registered-devices');

            deviceList.innerHTML = '';
            subscriptions.forEach((sub, index) => {
                const li = document.createElement('li');
                li.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 0.5rem; margin: 0.25rem 0; border: 1px solid var(--pico-muted-border-color); border-radius: var(--pico-border-radius);';

                const deviceInfo = document.createElement('span');
                const userAgent = sub.userAgent || 'Unknown device';
                const createdAt = new Date(sub.createdAt).toLocaleDateString();
                deviceInfo.textContent = `Device ${index + 1}: ${userAgent.substring(0, 50)}... (added ${createdAt})`;
                deviceInfo.style.flex = '1';

                const removeBtn = document.createElement('button');
                removeBtn.innerHTML = '&times;';
                removeBtn.className = 'secondary';
                removeBtn.style.cssText = 'padding: 0.25rem 0.5rem; margin: 0; font-size: 1.25rem; line-height: 1; min-width: auto;';
                removeBtn.setAttribute('aria-label', 'Remove device');
                removeBtn.onclick = () => removeDevice(sub.endpoint, li);

                li.appendChild(deviceInfo);
                li.appendChild(removeBtn);
                deviceList.appendChild(li);
            });

            devicesContainer.style.display = 'block';
        }
    } catch (error) {
        console.error('Failed to load registered devices:', error);
    }
}

async function removeDevice(endpoint, listItem) {
    if (!confirm('Remove this device from receiving notifications?')) {
        return;
    }

    try {
        const response = await fetch('/app/push/unsubscribe', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ endpoint })
        });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Failed to unsubscribe: ${response.status} ${errorText}`);
        }

        const result = await response.json();

        // Remove the device from the UI with animation
        listItem.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out';
        listItem.style.opacity = '0';
        listItem.style.transform = 'translateX(-20px)';

        setTimeout(async () => {
            listItem.remove();

            // Check if this was the last device
            const deviceList = document.getElementById('device-list');
            if (deviceList.children.length === 0) {
                document.getElementById('registered-devices').style.display = 'none';

                // If we removed the current device, disable notifications UI
                const currentEndpoint = await getCurrentDeviceEndpoint();
                if (currentEndpoint === endpoint) {
                    // Reset UI to not enabled state
                    const statusEl = document.getElementById('notification-permission-status');
                    const registerBtn = document.getElementById('register-device');
                    const prefsEl = document.getElementById('notification-preferences');

                    statusEl.textContent = 'Not enabled';
                    statusEl.style.color = '';
                    registerBtn.style.display = 'none';
                    prefsEl.style.display = 'none';

                    // Show enable button
                    document.getElementById('enable-notifications').style.display = 'block';
                }
            }

            showToast('Device removed from notifications', 'success');
        }, 300);

    } catch (error) {
        console.error('Failed to remove device:', error);
        showToast('Failed to remove device: ' + error.message, 'error');
    }
}

async function getCurrentDeviceEndpoint() {
    try {
        if (!('serviceWorker' in navigator) || !('PushManager' in window)) {
            return null;
        }

        const registration = await navigator.serviceWorker.ready;
        const subscription = await registration.pushManager.getSubscription();
        return subscription ? subscription.endpoint : null;
    } catch (error) {
        console.error('Failed to get current device endpoint:', error);
        return null;
    }
}

async function requestNotificationPermission() {
    try {
        const permission = await Notification.requestPermission();

        if (permission === 'granted') {
            showToast('Notifications enabled!', 'success');

            // Update UI to show preferences
            const statusEl = document.getElementById('notification-permission-status');
            const enableBtn = document.getElementById('enable-notifications');
            const registerBtn = document.getElementById('register-device');
            const prefsEl = document.getElementById('notification-preferences');

            statusEl.textContent = 'Enabled ✓';
            statusEl.style.color = 'var(--pico-primary)';
            enableBtn.style.display = 'none';
            registerBtn.style.display = 'inline-block';
            prefsEl.style.display = 'block';

            // Load current settings or use defaults (this populates the form)
            await loadNotificationSettings();

            // Create initial settings in AT Protocol with pushEnabled = true
            const initialSettings = {
                notifyOverdue: document.getElementById('notify-overdue').checked,
                notifyToday: document.getElementById('notify-today').checked,
                notifySoon: document.getElementById('notify-soon').checked,
                hoursBefore: parseInt(document.getElementById('notify-hours-before').value),
                checkFrequency: parseInt(document.getElementById('check-frequency').value),
                quietHoursEnabled: document.getElementById('quiet-hours-enabled').checked,
                quietStart: parseInt(document.getElementById('quiet-start').value),
                quietEnd: parseInt(document.getElementById('quiet-end').value),
                pushEnabled: true
            };

            try {
                const savedSettings = await saveSettings(initialSettings);
                currentSettings = savedSettings;
            } catch (error) {
                console.error('Failed to save initial settings:', error);
            }

            // Subscribe to push notifications
            const subResult = await subscribeToPush();

            // Show registration feedback
            if (subResult && subResult.message === 'Subscription created successfully') {
                showToast('Device registered for notifications!', 'success', 2000);
            } else if (subResult && subResult.message === 'Subscription already exists') {
                showToast('Device already registered', 'info', 2000);
            }

            // Reload devices list to show the new registration
            await loadRegisteredDevices();

            // Register periodic sync for background notifications
            await registerPeriodicSync();
        } else {
            showToast('Notification permission denied', 'error');
        }
    } catch (error) {
        console.error('Error requesting notification permission:', error);
        showToast('Failed to enable notifications: ' + error.message, 'error');
    }
}

async function loadNotificationSettings() {
    try {
        // Load from AT Protocol
        const settings = await loadSettings();
        currentSettings = settings;

        // Populate UI
        if (settings.notifyOverdue !== undefined) {
            document.getElementById('notify-overdue').checked = settings.notifyOverdue;
        }
        if (settings.notifyToday !== undefined) {
            document.getElementById('notify-today').checked = settings.notifyToday;
        }
        if (settings.notifySoon !== undefined) {
            document.getElementById('notify-soon').checked = settings.notifySoon;
        }
        if (settings.hoursBefore !== undefined) {
            document.getElementById('notify-hours-before').value = settings.hoursBefore;
        }
        if (settings.checkFrequency !== undefined) {
            document.getElementById('check-frequency').value = settings.checkFrequency;
        }
        if (settings.quietHoursEnabled !== undefined) {
            const quietCheckbox = document.getElementById('quiet-hours-enabled');
            quietCheckbox.checked = settings.quietHoursEnabled;
            // Show/hide quiet hours controls based on saved setting
            document.getElementById('quiet-hours-controls').style.display =
                settings.quietHoursEnabled ? 'block' : 'none';
        }
        if (settings.quietStart !== undefined) {
            document.getElementById('quiet-start').value = settings.quietStart;
        }
        if (settings.quietEnd !== undefined) {
            document.getElementById('quiet-end').value = settings.quietEnd;
        }
        if (settings.taskInputCollapsed !== undefined) {
            document.getElementById('task-input-collapsed').checked = settings.taskInputCollapsed;
        }

        return settings;
    } catch (error) {
        console.error('Failed to load notification settings:', error);
        return null;
    }
}

async function saveNotificationSettings() {
    const settings = {
        notifyOverdue: document.getElementById('notify-overdue').checked,
        notifyToday: document.getElementById('notify-today').checked,
        notifySoon: document.getElementById('notify-soon').checked,
        hoursBefore: parseInt(document.getElementById('notify-hours-before').value),
        checkFrequency: parseInt(document.getElementById('check-frequency').value),
        quietHoursEnabled: document.getElementById('quiet-hours-enabled').checked,
        quietStart: parseInt(document.getElementById('quiet-start').value),
        quietEnd: parseInt(document.getElementById('quiet-end').value),
        pushEnabled: Notification.permission === 'granted'
    };

    try {
        const updatedSettings = await saveSettings(settings);
        currentSettings = updatedSettings;
        showToast('Settings saved!', 'success');

        // Re-register periodic sync with new frequency
        if (Notification.permission === 'granted') {
            await registerPeriodicSync();
        }

        // Close the settings modal
        if (typeof closeSettings === 'function') {
            closeSettings();
        }
    } catch (error) {
        console.error('Failed to save notification settings:', error);
        showToast('Failed to save settings', 'error');
    }
}

async function testNotification() {
    if (Notification.permission !== 'granted') {
        showToast('Please enable notifications first', 'error');
        return;
    }

    try {
        // Call backend to send real push notification
        const response = await fetch('/app/push/test', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) {
            const error = await response.text();
            throw new Error(error || 'Failed to send test notification');
        }

        const result = await response.json();

        if (result.success) {
            showToast(`Test notification sent to ${result.sent} device(s)!`, 'success');

            // Close the settings modal so user can see the notification
            if (typeof closeSettings === 'function') {
                closeSettings();
            }
        } else {
            showToast('Failed to send test notification', 'error');
        }
    } catch (error) {
        console.error('Test notification error:', error);
        showToast('Error: ' + error.message, 'error');
    }
}

// Save UI preferences
async function saveUIPreferences() {
    try {
        // Load current settings first
        const settings = await loadSettings();

        // Update only the taskInputCollapsed field
        settings.taskInputCollapsed = document.getElementById('task-input-collapsed').checked;

        // Save back to server
        const updatedSettings = await saveSettings(settings);
        currentSettings = updatedSettings;
        showToast('UI preferences saved!', 'success');

        // Update the dashboard task input form state immediately
        const taskInputForm = document.getElementById('task-input-form');
        const toggleIcon = document.getElementById('toggle-icon');
        if (taskInputForm && toggleIcon) {
            if (settings.taskInputCollapsed) {
                taskInputForm.style.display = 'none';
                toggleIcon.textContent = '+';
            } else {
                taskInputForm.style.display = 'block';
                toggleIcon.textContent = '−';
            }
        }

        // Close the settings modal
        if (typeof closeSettings === 'function') {
            closeSettings();
        }
    } catch (error) {
        console.error('Failed to save UI preferences:', error);
        showToast('Failed to save UI preferences', 'error');
    }
}

// Subscribe to push notifications
async function subscribeToPush() {
    if (!('serviceWorker' in navigator) || !('PushManager' in window)) {
        console.warn('Push notifications not supported');
        return;
    }

    try {
        console.log('[Push] Waiting for service worker to be ready...');
        const registration = await navigator.serviceWorker.ready;
        console.log('[Push] Service worker ready');

        // Check if already subscribed
        let subscription = await registration.pushManager.getSubscription();
        console.log('[Push] Existing subscription:', subscription ? 'found' : 'not found');

        if (!subscription) {
            // Get VAPID public key from server
            console.log('[Push] Fetching VAPID public key...');
            const response = await fetch('/app/push/vapid-key');
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Failed to get VAPID public key: ${response.status} ${errorText}`);
            }
            const { publicKey } = await response.json();
            console.log('[Push] Got VAPID public key:', publicKey.substring(0, 20) + '...');

            // Subscribe to push notifications
            console.log('[Push] Subscribing to push manager...');
            subscription = await registration.pushManager.subscribe({
                userVisibleOnly: true,
                applicationServerKey: urlBase64ToUint8Array(publicKey)
            });
            console.log('[Push] Push manager subscription created');
        }

        // Send subscription to backend
        console.log('[Push] Registering subscription with backend...');
        const subscribeResponse = await fetch('/app/push/subscribe', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(subscription.toJSON())
        });

        if (!subscribeResponse.ok) {
            const errorText = await subscribeResponse.text();
            throw new Error(`Failed to register push subscription: ${subscribeResponse.status} ${errorText}`);
        }

        const result = await subscribeResponse.json();
        console.log('[Push] Subscription registered successfully:', result.message);

        // Return the result so caller can show appropriate message
        return result;
    } catch (error) {
        console.error('[Push] Failed to subscribe:', error);
        // Don't show toast on page load - only when user explicitly enables
        // showToast('Failed to set up push notifications', 'error');
        throw error;
    }
}

// Convert base64 VAPID key to Uint8Array
function urlBase64ToUint8Array(base64String) {
    const padding = '='.repeat((4 - base64String.length % 4) % 4);
    const base64 = (base64String + padding)
        .replace(/\-/g, '+')
        .replace(/_/g, '/');

    const rawData = window.atob(base64);
    const outputArray = new Uint8Array(rawData.length);

    for (let i = 0; i < rawData.length; ++i) {
        outputArray[i] = rawData.charCodeAt(i);
    }
    return outputArray;
}

// Register periodic background sync for notifications
async function registerPeriodicSync() {
    if (!('serviceWorker' in navigator)) {
        return;
    }

    // Check for periodic sync support
    if (!('periodicSync' in navigator.serviceWorker)) {
        // Fallback: use regular background sync
        if ('sync' in navigator.serviceWorker) {
            try {
                const registration = await navigator.serviceWorker.ready;
                await registration.sync.register('check-tasks');
            } catch (error) {
                // Background sync registration failed
            }
        }
        return;
    }

    try {
        const registration = await navigator.serviceWorker.ready;

        // Use current settings from AT Protocol
        const settings = currentSettings || await loadSettings();
        const frequency = settings.checkFrequency || 30; // minutes

        // Register periodic sync (Chrome/Edge only)
        await registration.periodicSync.register('check-due-tasks', {
            minInterval: frequency * 60 * 1000 // Convert minutes to milliseconds
        });
    } catch (error) {
        // Periodic sync registration failed
    }
}

// Note: showToast() function is defined globally in dashboard.html

// Initialize on page load
document.addEventListener('DOMContentLoaded', initNotificationSettings);

// Add event listener for enable button
document.getElementById('enable-notifications')?.addEventListener('click', requestNotificationPermission);

// Add event listener for register device button
document.getElementById('register-device')?.addEventListener('click', async () => {
    try {
        const result = await subscribeToPush();
        await loadRegisteredDevices();

        // Show appropriate message based on backend response
        if (result && result.message) {
            if (result.message === 'Subscription already exists') {
                showToast('This device is already registered for notifications', 'info');
            } else if (result.message === 'Subscription created successfully') {
                showToast('Device registered successfully!', 'success');
            } else {
                showToast('Device registration updated', 'success');
            }
        } else {
            showToast('Device registration refreshed!', 'success');
        }
    } catch (error) {
        console.error('Failed to register device:', error);
        showToast('Failed to register device: ' + error.message, 'error');
    }
});
</script>
{{end}}
